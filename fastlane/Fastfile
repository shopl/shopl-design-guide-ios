
default_platform(:ios)

# ğŸ”§ ì„¤ì • ë³€ìˆ˜
APP_BUNDLE_ID     = "com.shopl.designguide.ios"
APP_SCHEME        = "SDGSampleApp"
XCODE_PROJ        = "ShoplDesignGuide.xcodeproj"
XCODE_WORKSPACE   = "ShoplDesignGuide.xcworkspace"
FIREBASE_APP_ID   = "1:358638001737:ios:ffecd4783bbf774960a998"
TESTER_GROUPS     = "Design"
OUTPUT_DIR        = "./build_output"
IPA_NAME          = "SDGSampleApp.ipa"
INFO_PLIST_PATH   = "SampleApp/Resources/Info.plist"
GIT_REMOTE        = "origin"
TEAM_ID           = "4Z4H456LU8"

platform :ios do
  
  desc "SDG ìƒ˜í”Œ ì•± ë¹Œë“œ ë° Firebase ë°°í¬"
  lane :distribute do

    lane_context[:TRIGGERED_BY] = ENV["GITHUB_ACTOR"] || ENV["USER"] || "Unknown"
    
    begin
      
      # ë¹Œë“œ ì¤€ë¹„
      prepare_build
      
      # ë¦´ë¦¬ì¦ˆ ë…¸íŠ¸ ìƒì„±
      changelog = generate_changelog
      
      # í‚¤ì²´ì¸ ìƒì„± ë° Match ì‹¤í–‰
      prepare_certificates
      
      # ì•± ë¹Œë“œ
      build_ipa
      
      # Firebase ì—…ë¡œë“œ
      upload_to_firebase(changelog: changelog)
      
      # ë²„ì „ ì»¤ë°‹ & íƒœê·¸ í‘¸ì‹œ (ë°°í¬ ì„±ê³µ ì‹œ)
      commit_and_tag_version
      
      # ì„±ê³µ ì•Œë¦¼
      notify_slack_success(changelog: changelog)
      
    rescue => exception
      # ì‹¤íŒ¨ ì•Œë¦¼
      on_error(exception: exception)
      raise exception
      
    ensure
      cleanup_ci_keychain
    end
  end

  # ğŸ›  ë‚´ë¶€ ì‚¬ìš© ë ˆì¸
  private_lane :prepare_build do
    UI.message("ğŸ—ï¸ í”„ë¡œì íŠ¸ ìƒì„± ë° ë²„ì „ ì •ë³´ ë™ê¸°í™” ì¤‘...")
  
    sh("cd .. && tuist generate --no-open")
    
    target_version = "0.0.1"
    
    begin
      latest_lib_tag = sh("git describe --tags --match '[0-9]*.[0-9]*.[0-9]*' --exclude 'deploy/*' --abbrev=0 2>/dev/null").strip
      
      target_version = latest_lib_tag
      
      UI.success("ğŸ·ï¸ ê°ì§€ëœ ìµœì‹  ë¼ì´ë¸ŒëŸ¬ë¦¬ ë²„ì „: #{target_version} (Tag: #{latest_lib_tag})")
    rescue
      UI.error("âš ï¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë²„ì „ íƒœê·¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ê°’(#{target_version})ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.")
    end

    set_info_plist_value(
      path: INFO_PLIST_PATH,
      key: "CFBundleShortVersionString",
      value: target_version
    )
    
    if ENV["CI"]
      offset = 0
      build_number = (ENV["GITHUB_RUN_NUMBER"].to_i + offset).to_s
    else
      build_number = Time.now.strftime("%Y%m%d%H%M")
    end
    
    set_info_plist_value(
      path: INFO_PLIST_PATH,
      key: "CFBundleVersion",
      value: build_number
    )
    
    lane_context[:SDG_VERSION] = target_version
    lane_context[:SDG_BUILD_NUMBER] = build_number
    
    puts "ğŸ“± Target Version: #{target_version}(#{build_number})"
  end

  private_lane :generate_changelog do
    tag_prefix = "deploy/sample-app/"
    last_app_tag = nil
    
    begin
      last_app_tag = sh("git describe --tags --match '#{tag_prefix}*' --abbrev=0 2>/dev/null", log: false).strip
      UI.message("ğŸ” ë§ˆì§€ë§‰ ìƒ˜í”Œ ì•± ë°°í¬ íƒœê·¸ ë°œê²¬: #{last_app_tag}")
    rescue
      UI.message("âœ¨ ì´ì „ ë°°í¬ íƒœê·¸ ì—†ìŒ. ì „ì²´ ì»¤ë°‹ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.")
    end
    
    if last_app_tag
      # ê¸°ì¤€ íƒœê·¸ê°€ ìˆìœ¼ë©´ [íƒœê·¸ ~ HEAD]
      range_options = { between: [last_app_tag, "HEAD"] }
    else
      # ê¸°ì¤€ íƒœê·¸ê°€ ì—†ìœ¼ë©´ [ë¿Œë¦¬ ì»¤ë°‹ ~ HEAD]
      # git rev-list --max-parents=0 HEAD : ì €ì¥ì†Œì˜ ê°€ì¥ ì²« ì»¤ë°‹ í•´ì‹œë¥¼ ê°€ì ¸ì˜´
      root_commit = sh("git rev-list --max-parents=0 HEAD", log: false).strip
      range_options = { between: [root_commit, "HEAD"] }
    end
    
    raw_changelog = changelog_from_git_commits(
      merge_commit_filtering: "exclude_merges",
      match_lightweight_tag: false,
      pretty: "%h|%s",
      **range_options
    )
    
    puts "---------------------------------------------------"
    puts "ğŸ” Fastlaneì´ ì½ì–´ì˜¨ Raw Changelog ëª©ë¡:"
    puts raw_changelog.empty? ? "(ì—†ìŒ - ì»¤ë°‹ì„ ì°¾ì§€ ëª»í•¨)" : raw_changelog
    puts "---------------------------------------------------"

    # key: ì»¤ë°‹ prefix, value: ì¶œë ¥ë  ì„¹ì…˜ ì œëª©
    category_map = {
      "feat" => "âœ¨ Features",
      "design" => "ğŸ¨ Design",
      "fix" => "ğŸ› Bug Fixes"
    }

    # ê·¸ë£¹í™”í•  ì €ì¥ì†Œ ì´ˆê¸°í™”
    grouped_commits = Hash.new { |h, k| h[k] = [] }
    
    current_target_version = lane_context[:SDG_VERSION] || "Unreleased"
    
    raw_changelog.split("\n").each do |line|
      clean_line = line.strip
      # í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì— ì»¤ë°‹ì´ ì—†ìœ¼ë©´ ìŠ¤í‚µ
      next if clean_line.empty?
      
      # í•´ì‹œì™€ ë©”ì‹œì§€ ë¶„ë¦¬
      commit_hash, full_message = clean_line.split("|", 2)
      full_message ||= ""

      # ì‹œì‘ì´ prefixì´ê³ , ê´„í˜¸(scope)ê°€ ìˆì„ ìˆ˜ë„ ìˆê³ , ì½œë¡ ìœ¼ë¡œ ëë‚¨
      found_prefix = category_map.keys.find do |prefix|
        full_message.downcase.match?(/^#{prefix}(\(.*\))?\s*:/)
      end

      if found_prefix
        message_content = full_message.sub(/^#{found_prefix}(\(.*\))?\s*:/, "").strip
        
        # ì»¤ë°‹ í•´ì‹œë¡œ ì†Œì† ë²„ì „(Tag) ì°¾ê¸°
        begin
          found_tag = sh("git describe --contains #{commit_hash} --match '[0-9]*.[0-9]*.[0-9]*' --exclude 'deploy/*' 2>/dev/null", log: false).strip.split(/[~^]/).first
          
          version_badge = found_tag
        rescue
          # íƒœê·¸ë¥¼ ëª» ì°¾ìŒ = ì•„ì§ íƒœê·¸ê°€ ì•ˆ ë‹¬ë¦° ìµœì‹  ì»¤ë°‹ (í˜„ì¬ ë¹Œë“œ ë²„ì „)
          version_badge = current_target_version
        end

        # ë©”ì‹œì§€ ë’¤ì— ë²„ì „ ë±ƒì§€ ë¶€ì°©
        formatted_message = "#{message_content} (v#{version_badge})"
        
        section_title = category_map[found_prefix]
        grouped_commits[section_title] << formatted_message
      end
    end

    final_changelog = ""

    category_map.values.each do |title|
      commits = grouped_commits[title]
      next if commits.empty?

      final_changelog += "\n*#{title}*\n"
      commits.each { |msg| final_changelog += "- #{msg}\n" }
    end

    if final_changelog.strip.empty?
      final_changelog = "- ì‚¬ì†Œí•œ ë²„ê·¸ ìˆ˜ì • ë° ì•ˆì •ì„± ê°œì„ "
    end

    puts "ğŸ“ Categorized Changelog with Versions:\n#{final_changelog}"
    
    final_changelog.strip
  end

  private_lane :prepare_certificates do
    
    UI.message("ğŸ—ï¸ CI í™˜ê²½ ì…‹ì—… ë° í‚¤ì²´ì¸ ì¤€ë¹„ ì¤‘...")
    
    setup_ci(
      force: true
    )
    
    temp_keychain_name = "fastlane_tmp_keychain"
    temp_keychain_password = ""
        
    keychain_path = Actions.lane_context[SharedValues::KEYCHAIN_PATH]

    if keychain_path.nil?
      keychain_path = File.expand_path("~/Library/Keychains/#{temp_keychain_name}-db")
    end
    
    unlock_keychain(
      path: keychain_path,
      password: temp_keychain_password
    )
    
    # Match ì‹¤í–‰
    match(
      type: "adhoc",
      app_identifier: APP_BUNDLE_ID,
      readonly: true,
      keychain_name: temp_keychain_name,
      keychain_password: temp_keychain_password
    )
    
    UI.message("ğŸ—‚ï¸ í‚¤ì²´ì¸ ê²€ìƒ‰ ëª©ë¡ ì—…ë°ì´íŠ¸ ì¤‘...")
    sh("security list-keychains -s #{keychain_path} $(security list-keychains -d user)")
    
    # ì ‘ê·¼ ê¶Œí•œ í•´ì œ
    UI.message("ğŸ”“ í‚¤ì²´ì¸ ê¶Œí•œ(ACL) í•´ì œ ì¤‘...")
    sh("security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k '' #{keychain_path}")
  end
    
  private_lane :build_ipa do
    profile_name = ENV["sigh_#{APP_BUNDLE_ID}_adhoc_profile-name"]
    
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODE_PROJ,
      targets: [APP_SCHEME],
      code_sign_identity: "Apple Distribution",
      bundle_identifier: APP_BUNDLE_ID,
      profile_name: profile_name
    )
    
    build_app(
      workspace: XCODE_WORKSPACE,
      scheme: APP_SCHEME,
      export_method: "ad-hoc",
      clean: true,
      output_directory: OUTPUT_DIR,
      output_name: IPA_NAME,
      export_options: {
        method: "ad-hoc",
        signingStyle: "manual",
        teamID: TEAM_ID,
        provisioningProfiles: {
          APP_BUNDLE_ID => profile_name
        }
      }
    )
  end

  private_lane :upload_to_firebase do |options|
    version = lane_context[:SDG_VERSION]
    build_num = lane_context[:SDG_BUILD_NUMBER]
    
    firebase_app_distribution(
      app: FIREBASE_APP_ID,
      groups: TESTER_GROUPS,
      release_notes: "Ver: #{version}(#{build_num})\n\n[ë³€ê²½ ì‚¬í•­]\n#{options[:changelog]}",
      service_credentials_json_data: ENV["FIREBASE_SERVICE_ACCOUNT_JSON"]
    )
  end

  private_lane :notify_slack_success do |options|
    version = lane_context[:SDG_VERSION]
    build_num = lane_context[:SDG_BUILD_NUMBER]
    triggered_by = lane_context[:TRIGGERED_BY]

    slack(
      message: "ğŸš€ SDG ìƒ˜í”Œì•±(iOS) ë°°í¬ ì™„ë£Œ!",
      success: true,
      payload: {
        "Version" => "#{version} (#{build_num})",
        "Change Log" => options[:changelog],
        "Triggered By" => triggered_by
      },
      default_payloads: [],
      slack_url: ENV["SLACK_URL"]
    )
  end
  
  private_lane :commit_and_tag_version do
    version = lane_context[:SDG_VERSION]
    build_num = lane_context[:SDG_BUILD_NUMBER]
    tag_name = "deploy/sample-app/#{version}_#{build_num}"
    
    add_git_tag(
      tag: tag_name,
      message: "Sample App Deployment for Lib #{version}"
    )
    
    current_branch = git_branch
    
    if current_branch.to_s.empty? || current_branch == "HEAD"
      current_branch = ENV["GITHUB_REF_NAME"]
    end
    
    push_to_git_remote(
      remote: GIT_REMOTE,
      local_branch: current_branch,
      remote_branch: current_branch,
      tags: true
    )
    
    puts "âœ… Deployed Tag: #{tag_name}"
  end
  
  private_lane :on_error do |options|
    exception = options[:exception]
    triggered_by = lane_context[:TRIGGERED_BY]

    slack(
      message: "ğŸ”¥ SDG ìƒ˜í”Œ ì•± ë°°í¬ ì‹¤íŒ¨: #{exception.message}",
      success: false,
      payload: { "Triggered By" => triggered_by },
      slack_url: ENV["SLACK_URL"]
    )
  end
  
  private_lane :cleanup_ci_keychain do
    keychain_path = Actions.lane_context[SharedValues::KEYCHAIN_PATH]
    
    target_name = "fastlane_tmp_keychain"
    
    real_path = keychain_path
    if keychain_path && !File.exist?(keychain_path)
      potential_db_path = "#{keychain_path}-db"
      if File.exist?(potential_db_path)
        real_path = potential_db_path
      end
    end
    
    real_path = keychain_path || File.expand_path("~/Library/Keychains/#{target_name}-db")
    
    if File.exist?(real_path)
      UI.message("ğŸ§¹ ì„ì‹œ í‚¤ì²´ì¸ ë’·ì •ë¦¬ ì¤‘...")
      
      # ì„ì‹œ í‚¤ì²´ì¸ ì‚­ì œí•˜ê¸° ìœ„í•´ ê¸°ë³¸ í‚¤ì²´ì¸ì„ ë¡œê·¸ì¸ í‚¤ì²´ì¸ìœ¼ë¡œ ì›ë³µ
      sh("security default-keychain -s login.keychain-db || true")
      
      delete_keychain(name: target_name)
      
      UI.success("âœ¨ í‚¤ì²´ì¸ ì‚­ì œ ì™„ë£Œ")
    else
      UI.message("â„¹ï¸ ì‚­ì œí•  í‚¤ì²´ì¸ì´ ì—†ìŠµë‹ˆë‹¤.")
    end
  end
end
