
default_platform(:ios)

# ğŸ”§ ì„¤ì • ë³€ìˆ˜
APP_BUNDLE_ID     = "com.shopl.designguide.ios"
APP_SCHEME        = "SDGSampleApp"
XCODE_PROJ        = "ShoplDesignGuide.xcodeproj"
XCODE_WORKSPACE   = "ShoplDesignGuide.xcworkspace"
FIREBASE_APP_ID   = "1:358638001737:ios:ffecd4783bbf774960a998"
TESTER_GROUPS     = "Design"
OUTPUT_DIR        = "./build_output"
IPA_NAME          = "SDGSampleApp.ipa"
INFO_PLIST_PATH   = "SampleApp/Resources/Info.plist"
GIT_REMOTE        = "origin"
KEYCHAIN_NAME     = "sdg_sample_keychain"
TEAM_ID           = "4Z4H456LU8"

platform :ios do
  
  desc "SDG ìƒ˜í”Œ ì•± ë¹Œë“œ ë° Firebase ë°°í¬"
  lane :distribute do

    lane_context[:TRIGGERED_BY] = ENV["GITHUB_ACTOR"] || ENV["USER"] || "Unknown"
    
    begin
      
      # ë¹Œë“œ ì¤€ë¹„
      prepare_build
      
      # ë¦´ë¦¬ì¦ˆ ë…¸íŠ¸ ìƒì„±
      changelog = generate_changelog
      
      # ì„ì‹œ í‚¤ì²´ì¸ ìƒì„± ë° ì¸ì¦ì„œ ë™ê¸°í™”
      prepare_certificates_and_keychain
      
      # ì•± ë¹Œë“œ
      build_ipa
      
      # Firebase ì—…ë¡œë“œ
      upload_to_firebase(changelog: changelog)
      
      # ë²„ì „ ì»¤ë°‹ & íƒœê·¸ í‘¸ì‹œ (ë°°í¬ ì„±ê³µ ì‹œ)
      commit_and_tag_version
      
      # ì„±ê³µ ì•Œë¦¼
      notify_slack_success(changelog: changelog)
      
    rescue => exception
      # ì‹¤íŒ¨ ì•Œë¦¼
      on_error(exception: exception)
      raise exception
      
    ensure
      cleanup_keychain
    end
  end

  # ğŸ›  ë‚´ë¶€ ì‚¬ìš© ë ˆì¸
  private_lane :prepare_build do
    sh("cd .. && tuist generate --no-open")
    
    current_version = get_info_plist_value(path: INFO_PLIST_PATH, key: "CFBundleShortVersionString")
    bump_type = ENV["BUMP_TYPE"] || "patch"
    
    # ë²„ì „ ì˜¬ë¦¬ê¸°
    version = current_version
    
    if bump_type != "skip"
      major, minor, patch = current_version.split(".").map(&:to_i)

      case bump_type
      when "major"
        major += 1
        minor = 0
        patch = 0
      when "minor"
        minor += 1
        patch = 0
      when "patch"
        patch += 1
      end

      version = "#{major}.#{minor}.#{patch}"
      
      set_info_plist_value(
        path: INFO_PLIST_PATH,
        key: "CFBundleShortVersionString",
        value: version
      )
    end
    
    if ENV["CI"]
      offset = 0
      build_number = (ENV["GITHUB_RUN_NUMBER"].to_i + offset).to_s
    else
      build_number = Time.now.strftime("%Y%m%d%H%M")
    end
    
    set_info_plist_value(
      path: INFO_PLIST_PATH,
      key: "CFBundleVersion",
      value: build_number
    )
    
    lane_context[:SDG_VERSION] = version
    lane_context[:SDG_BUILD_NUMBER] = build_number
    lane_context[:SDG_BUMP_TYPE] = bump_type
    
    puts "ğŸ“± Target Version: #{version} (#{build_number}) / Bump Type: #{bump_type}"
  end

  private_lane :generate_changelog do
    raw_changelog = changelog_from_git_commits(
      merge_commit_filtering: "exclude_merges",
      match_lightweight_tag: false,
      pretty: "%s"
    )

    # key: ì»¤ë°‹ prefix, value: ì¶œë ¥ë  ì„¹ì…˜ ì œëª©
    category_map = {
      "feat" => "âœ¨ Features",
      "design" => "ğŸ¨ Design",
      "fix" => "ğŸ› Bug Fixes"
    }

    # ê·¸ë£¹í™”í•  ì €ì¥ì†Œ ì´ˆê¸°í™”
    grouped_commits = Hash.new { |h, k| h[k] = [] }

    raw_changelog.split("\n").each do |line|
      clean_line = line.strip
      # í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì— ì»¤ë°‹ì´ ì—†ìœ¼ë©´ ìŠ¤í‚µ
      next if clean_line.empty?

      # ì‹œì‘ì´ prefixì´ê³ , ê´„í˜¸(scope)ê°€ ìˆì„ ìˆ˜ë„ ìˆê³ , ì½œë¡ ìœ¼ë¡œ ëë‚¨
      found_prefix = category_map.keys.find do |prefix|
        clean_line.downcase.match?(/^#{prefix}(\(.*\))?:/)
      end

      if found_prefix
        # ë©”ì‹œì§€ ë‚´ìš©ë§Œ ì¶”ì¶œ (prefix ì œê±°)
        message_content = clean_line.sub(/^#{found_prefix}(\(.*\))?:/, "").strip
        
        # ë§¤í•‘ëœ ì„¹ì…˜ ì œëª©ìœ¼ë¡œ ì €ì¥
        section_title = category_map[found_prefix]
        grouped_commits[section_title] << message_content
      end
    end

    final_changelog = ""

    category_map.values.each do |title|
      commits = grouped_commits[title]
      next if commits.empty?

      final_changelog += "\n*#{title}*\n"
      
      commits.each do |msg|
        final_changelog += "- #{msg}\n"
      end
    end

    # íƒ€ì…ì´ ì¼ì¹˜í•˜ëŠ” ì»¤ë°‹ ì—†ì„ ê²½ìš° ê¸°ë³¸ê°’
    if final_changelog.strip.empty?
      final_changelog = "- ì‚¬ì†Œí•œ ë²„ê·¸ ìˆ˜ì • ë° ì•ˆì •ì„± ê°œì„ "
    end

    puts "ğŸ“ Categorized Changelog:\n#{final_changelog}"
    
    final_changelog.strip
  end

  private_lane :prepare_certificates_and_keychain do
    
    UI.message("ğŸ” SDG ì „ìš© ì„ì‹œ í‚¤ì²´ì¸ ìƒì„± ì¤‘: #{KEYCHAIN_NAME}")
    
    cleanup_keychain

    # ìƒˆ í‚¤ì²´ì¸ ìƒì„±
    create_keychain(
      name: KEYCHAIN_NAME,
      password: "",
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )
    
    # Match ì‹¤í–‰
    match(
      type: "adhoc",
      app_identifier: APP_BUNDLE_ID,
      readonly: true,
      keychain_name: KEYCHAIN_NAME,
      keychain_password: ""
    )
    
    # ì ‘ê·¼ ê¶Œí•œ í•´ì œ
    UI.message("ğŸ”“ í‚¤ì²´ì¸ ê¶Œí•œ í•´ì œ ì¤‘...")
    
    kc_pasth = File.expand_path("~/Library/Keychains/#{KEYCHAIN_NAME}-db")
        
    sh("security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k '' #{kc_pasth}")
  end
  
  private_lane :cleanup_keychain do
    UI.message("ğŸ§¹ SDG í‚¤ì²´ì¸ ì •ë¦¬ ì¤‘...")
    
    Actions.lane_context[SharedValues::KEYCHAIN_PATH] = nil
    
    keychain_path = File.expand_path("~/Library/Keychains/#{KEYCHAIN_NAME}-db")
    
    if File.exist?(keychain_path)
      delete_keychain(name: KEYCHAIN_NAME)
      UI.success("âœ… í‚¤ì²´ì¸ ì‚­ì œ ì™„ë£Œ")
    end
  end
  
  private_lane :build_ipa do
    profile_name = ENV["sigh_#{APP_BUNDLE_ID}_adhoc_profile-name"]
    
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODE_PROJ,
      targets: [APP_SCHEME],
      code_sign_identity: "Apple Distribution",
      bundle_identifier: APP_BUNDLE_ID,
      profile_name: profile_name
    )
    
    build_app(
      workspace: XCODE_WORKSPACE,
      scheme: APP_SCHEME,
      export_method: "ad-hoc",
      clean: true,
      output_directory: OUTPUT_DIR,
      output_name: IPA_NAME,
      export_options: {
        method: "ad-hoc",
        signingStyle: "manual",
        teamID: TEAM_ID,
        provisioningProfiles: {
          APP_BUNDLE_ID => profile_name
        }
      }
    )
  end

  private_lane :upload_to_firebase do |options|
    version = lane_context[:SDG_VERSION]
    build_num = lane_context[:SDG_BUILD_NUMBER]
    
    firebase_app_distribution(
      app: FIREBASE_APP_ID,
      groups: TESTER_GROUPS,
      release_notes: "Ver: #{version} (Build: #{build_num})\n\n[ë³€ê²½ ì‚¬í•­]\n#{options[:changelog]}",
      service_credentials_json_data: ENV["FIREBASE_SERVICE_ACCOUNT_JSON"]
    )
  end

  private_lane :notify_slack_success do |options|
    version = lane_context[:SDG_VERSION]
    build_num = lane_context[:SDG_BUILD_NUMBER]
    bump_type = lane_context[:SDG_BUMP_TYPE]
    triggered_by = lane_context[:TRIGGERED_BY]

    slack(
      message: "ğŸš€ SDG ìƒ˜í”Œì•±(iOS) ë°°í¬ ì™„ë£Œ!",
      success: true,
      payload: {
        "Version" => "#{version} (#{build_num})",
        "Change Log" => options[:changelog],
        "Triggered By" => triggered_by,
        "Bump Type" => bump_type
      },
      default_payloads: [],
      slack_url: ENV["SLACK_URL"]
    )
  end
  
  private_lane :commit_and_tag_version do
    version = lane_context[:SDG_VERSION]
    build_num = lane_context[:SDG_BUILD_NUMBER]
    tag_name = "#{version}_#{build_num}"
    
    git_commit(
      path: [INFO_PLIST_PATH],
      message: "chore: bump version to #{version} (#{build_num}) [skip ci]"
    )
    
    add_git_tag(
      tag: tag_name,
      message: "Auto deployment release #{tag_name}"
    )
    
    current_branch = git_branch
    
    if current_branch.to_s.empty? || current_branch == "HEAD"
      current_branch = ENV["GITHUB_REF_NAME"]
    end
    
    push_to_git_remote(
      remote: ENV["GIT_REMOTE"],
      local_branch: current_branch,
      remote_branch: current_branch,
      tags: true
    )
    
    puts "âœ… Git Commit & Tag Pushed: #{tag_name}"
  end
  
  private_lane :on_error do |options|
    exception = options[:exception]
    triggered_by = lane_context[:TRIGGERED_BY]

    slack(
      message: "ğŸ”¥ SDG ìƒ˜í”Œ ì•± ë°°í¬ ì‹¤íŒ¨: #{exception.message}",
      success: false,
      payload: { "Triggered By" => triggered_by },
      slack_url: ENV["SLACK_URL"]
    )
  end
end
